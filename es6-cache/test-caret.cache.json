{"modules":{"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/browser.js":{"file":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/browser.js","source":"\"use strict\";\n\nvar ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n\nmodule.exports = {\n  mac: /Mac/.test(navigator.platform),\n  ie: ie_upto10 || !!ie_11up,\n  ie_version: ie_upto10 ? document.documentMode || 6 : ie_11up && +ie_11up[1],\n  gecko: /gecko\\/\\d/i.test(navigator.userAgent),\n  ios: /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent)\n};","deps":{}},"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/dom.js":{"file":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/dom.js","source":"\"use strict\";\n\nfunction elt(tag, attrs) {\n  var result = document.createElement(tag);\n  if (attrs) for (var name in attrs) {\n    if (name == \"style\") result.style.cssText = attrs[name];else if (attrs[name] != null) result.setAttribute(name, attrs[name]);\n  }\n\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    add(args[i], result);\n  }return result;\n}\nexports.elt = elt;\n\nfunction add(value, target) {\n  if (typeof value == \"string\") value = document.createTextNode(value);\n\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      add(value[i], target);\n    }\n  } else {\n    target.appendChild(value);\n  }\n}\n\nvar reqFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\nvar cancelFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n\nfunction requestAnimationFrame(f) {\n  if (reqFrame) return reqFrame.call(window, f);else return setTimeout(f, 10);\n}\nexports.requestAnimationFrame = requestAnimationFrame;\n\nfunction cancelAnimationFrame(handle) {\n  if (reqFrame) return cancelFrame.call(window, handle);else clearTimeout(handle);\n}\nexports.cancelAnimationFrame = cancelAnimationFrame;\n\n// : (DOMNode, DOMNode) → bool\n// Check whether a DOM node is an ancestor of another DOM node.\nfunction contains(parent, child) {\n  // Android browser and IE will return false if child is a text node.\n  if (child.nodeType != 1) child = child.parentNode;\n  return child && parent.contains(child);\n}\nexports.contains = contains;\n\nvar accumulatedCSS = \"\",\n    cssNode = null;\n\nfunction insertCSS(css) {\n  if (cssNode) cssNode.textContent += css;else accumulatedCSS += css;\n}\nexports.insertCSS = insertCSS;\n\n// This is called when a ProseMirror instance is created, to ensure\n// the CSS is in the DOM.\nfunction ensureCSSAdded() {\n  if (!cssNode) {\n    cssNode = document.createElement(\"style\");\n    cssNode.textContent = \"/* ProseMirror CSS */\\n\" + accumulatedCSS;\n    document.head.insertBefore(cssNode, document.head.firstChild);\n  }\n}\nexports.ensureCSSAdded = ensureCSSAdded;","deps":{}},"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/dompos.js":{"file":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/dompos.js","source":"\"use strict\";\n\nvar _require = require(\"../util/dom\"),\n    contains = _require.contains;\n\nfunction isEditorContent(dom) {\n  return dom.classList.contains(\"ProseMirror-content\");\n}\n\n// : (DOMNode) → number\n// Get the position before a given a DOM node in a document.\nfunction posBeforeFromDOM(node) {\n  var pos = 0,\n      add = 0;\n  for (var cur = node; !isEditorContent(cur); cur = cur.parentNode) {\n    var attr = cur.getAttribute(\"pm-offset\");\n    if (attr) {\n      pos += +attr + add;add = 1;\n    }\n  }\n  return pos;\n}\n\nvar posFromDOMResult = { pos: 0, inLeaf: -1 };\n\n// : (DOMNode, number) → number\nfunction posFromDOM(dom, domOffset) {\n  var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (domOffset == null) {\n    domOffset = Array.prototype.indexOf.call(dom.parentNode.childNodes, dom);\n    dom = dom.parentNode;\n  }\n\n  // Move up to the wrapping container, counting local offset along\n  // the way.\n  var innerOffset = 0,\n      tag = void 0;\n  for (;;) {\n    var adjust = 0;\n    if (dom.nodeType == 3) {\n      innerOffset += domOffset;\n    } else if (tag = dom.getAttribute(\"pm-offset\") && !childContainer(dom)) {\n      var size = +dom.getAttribute(\"pm-size\");\n      if (dom.nodeType == 1 && !dom.firstChild) innerOffset = bias > 0 ? size : 0;else if (domOffset == dom.childNodes.length) innerOffset = size;else innerOffset = Math.min(innerOffset, size);\n      var inLeaf = posFromDOMResult.inLeaf = posBeforeFromDOM(dom);\n      posFromDOMResult.pos = inLeaf + innerOffset;\n      return posFromDOMResult;\n    } else if (dom.hasAttribute(\"pm-container\")) {\n      break;\n    } else if (domOffset == dom.childNodes.length) {\n      if (domOffset) adjust = 1;else adjust = bias > 0 ? 1 : 0;\n    }\n\n    var parent = dom.parentNode;\n    domOffset = adjust < 0 ? 0 : Array.prototype.indexOf.call(parent.childNodes, dom) + adjust;\n    dom = parent;\n    bias = 0;\n  }\n\n  var start = isEditorContent(dom) ? 0 : posBeforeFromDOM(dom) + 1,\n      before = 0;\n\n  for (var child = dom.childNodes[domOffset - 1]; child; child = child.previousSibling) {\n    if (child.nodeType == 1 && (tag = child.getAttribute(\"pm-offset\"))) {\n      before += +tag + +child.getAttribute(\"pm-size\");\n      break;\n    }\n  }\n  posFromDOMResult.inLeaf = -1;\n  posFromDOMResult.pos = start + before + innerOffset;\n  return posFromDOMResult;\n}\nexports.posFromDOM = posFromDOM;\n\n// : (DOMNode) → ?DOMNode\nfunction childContainer(dom) {\n  return dom.hasAttribute(\"pm-container\") ? dom : dom.querySelector(\"[pm-container]\");\n}\nexports.childContainer = childContainer;\n\n// : (ProseMirror, number) → {node: DOMNode, offset: number}\n// Find the DOM node and offset into that node that the given document\n// position refers to.\nfunction DOMFromPos(pm, pos, loose) {\n  if (!loose && pm.operation && pm.doc != pm.operation.doc) throw new RangeError(\"Resolving a position in an outdated DOM structure\");\n\n  var container = pm.content,\n      offset = pos;\n  for (;;) {\n    for (var child = container.firstChild, i = 0;; child = child.nextSibling, i++) {\n      if (!child) {\n        if (offset && !loose) throw new RangeError(\"Failed to find node at \" + pos);\n        return { node: container, offset: i };\n      }\n\n      var size = child.nodeType == 1 && child.getAttribute(\"pm-size\");\n      if (size) {\n        if (!offset) return { node: container, offset: i };\n        size = +size;\n        if (offset < size) {\n          container = childContainer(child);\n          if (!container) {\n            return leafAt(child, offset);\n          } else {\n            offset--;\n            break;\n          }\n        } else {\n          offset -= size;\n        }\n      }\n    }\n  }\n}\nexports.DOMFromPos = DOMFromPos;\n\n// : (ProseMirror, number) → {node: DOMNode, offset: number}\n// The same as DOMFromPos, but searching from the bottom instead of\n// the top. This is needed in domchange.js, when there is an arbitrary\n// DOM change somewhere in our document, and we can no longer rely on\n// the DOM structure around the selection.\nfunction DOMFromPosFromEnd(pm, pos) {\n  var container = pm.content,\n      dist = (pm.operation ? pm.operation.doc : pm.doc).content.size - pos;\n  for (;;) {\n    for (var child = container.lastChild, i = container.childNodes.length;; child = child.previousSibling, i--) {\n      if (!child) return { node: container, offset: i };\n\n      var size = child.nodeType == 1 && child.getAttribute(\"pm-size\");\n      if (size) {\n        if (!dist) return { node: container, offset: i };\n        size = +size;\n        if (dist < size) {\n          container = childContainer(child);\n          if (!container) {\n            return leafAt(child, size - dist);\n          } else {\n            dist--;\n            break;\n          }\n        } else {\n          dist -= size;\n        }\n      }\n    }\n  }\n}\nexports.DOMFromPosFromEnd = DOMFromPosFromEnd;\n\n// : (ProseMirror, number) → DOMNode\nfunction DOMAfterPos(pm, pos) {\n  var _DOMFromPos = DOMFromPos(pm, pos),\n      node = _DOMFromPos.node,\n      offset = _DOMFromPos.offset;\n\n  if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n  return node.childNodes[offset];\n}\nexports.DOMAfterPos = DOMAfterPos;\n\n// : (DOMNode, number) → {node: DOMNode, offset: number}\nfunction leafAt(node, offset) {\n  for (;;) {\n    var child = node.firstChild;\n    if (!child) return { node: node, offset: offset };\n    if (child.nodeType != 1) return { node: child, offset: offset };\n    node = child;\n  }\n}\n\nfunction windowRect() {\n  return { left: 0, right: window.innerWidth,\n    top: 0, bottom: window.innerHeight };\n}\n\nfunction parentNode(node) {\n  var parent = node.parentNode;\n  return parent.nodeType == 11 ? parent.host : parent;\n}\n\nfunction scrollIntoView(pm, pos) {\n  if (!pos) pos = pm.sel.range.head || pm.sel.range.from;\n  var coords = coordsAtPos(pm, pos);\n  for (var parent = pm.content;; parent = parentNode(parent)) {\n    var _pm$options = pm.options,\n        scrollThreshold = _pm$options.scrollThreshold,\n        scrollMargin = _pm$options.scrollMargin;\n\n    var atBody = parent == document.body;\n    var rect = atBody ? windowRect() : parent.getBoundingClientRect();\n    var moveX = 0,\n        moveY = 0;\n    if (coords.top < rect.top + scrollThreshold) moveY = -(rect.top - coords.top + scrollMargin);else if (coords.bottom > rect.bottom - scrollThreshold) moveY = coords.bottom - rect.bottom + scrollMargin;\n    if (coords.left < rect.left + scrollThreshold) moveX = -(rect.left - coords.left + scrollMargin);else if (coords.right > rect.right - scrollThreshold) moveX = coords.right - rect.right + scrollMargin;\n    if (moveX || moveY) {\n      if (atBody) {\n        window.scrollBy(moveX, moveY);\n      } else {\n        if (moveY) parent.scrollTop += moveY;\n        if (moveX) parent.scrollLeft += moveX;\n      }\n    }\n    if (atBody) break;\n  }\n}\nexports.scrollIntoView = scrollIntoView;\n\nfunction findOffsetInNode(node, coords) {\n  var closest = void 0,\n      dxClosest = 2e8,\n      coordsClosest = void 0,\n      offset = 0;\n  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    var rects = void 0;\n    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i];\n      if (rect.top <= coords.top && rect.bottom >= coords.top) {\n        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n        if (dx < dxClosest) {\n          closest = child;\n          dxClosest = dx;\n          coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;\n          if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n          continue;\n        }\n      }\n      if (!closest && (coords.left >= rect.right || coords.left >= rect.left && coords.top >= rect.bottom)) offset = i + 1;\n    }\n  }\n  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n  if (!closest || dxClosest && closest.nodeType == 1) return { node: node, offset: offset };\n  return findOffsetInNode(closest, coordsClosest);\n}\n\nfunction findOffsetInText(node, coords) {\n  var len = node.nodeValue.length;\n  var range = document.createRange();\n  for (var i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    var rect = singleRect(range, 1);\n    if (rect.top == rect.bottom) continue;\n    if (rect.left - 1 <= coords.left && rect.right + 1 >= coords.left && rect.top - 1 <= coords.top && rect.bottom + 1 >= coords.top) return { node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n  }\n  return { node: node, offset: 0 };\n}\n\nfunction targetKludge(dom, coords) {\n  if (/^[uo]l$/i.test(dom.nodeName)) {\n    for (var child = dom.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType != 1 || !child.hasAttribute(\"pm-offset\") || !/^li$/i.test(child.nodeName)) continue;\n      var childBox = child.getBoundingClientRect();\n      if (coords.left > childBox.left - 2) break;\n      if (childBox.top <= coords.top && childBox.bottom >= coords.top) return child;\n    }\n  }\n  return dom;\n}\n\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(pm, coords) {\n  var elt = targetKludge(pm.root.elementFromPoint(coords.left, coords.top + 1), coords);\n  if (!contains(pm.content, elt)) return null;\n\n  var _findOffsetInNode = findOffsetInNode(elt, coords),\n      node = _findOffsetInNode.node,\n      offset = _findOffsetInNode.offset,\n      bias = -1;\n\n  if (node.nodeType == 1 && !node.firstChild) {\n    var rect = node.getBoundingClientRect();\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n  }\n  return posFromDOM(node, offset, bias);\n}\nexports.posAtCoords = posAtCoords;\n\nfunction textRange(node, from, to) {\n  var range = document.createRange();\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range;\n}\n\nfunction singleRect(object, bias) {\n  var rects = object.getClientRects();\n  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];\n}\n\n// : (ProseMirror, number) → ClientRect\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(pm, pos) {\n  var _DOMFromPos2 = DOMFromPos(pm, pos),\n      node = _DOMFromPos2.node,\n      offset = _DOMFromPos2.offset;\n\n  var side = void 0,\n      rect = void 0;\n  if (node.nodeType == 3) {\n    if (offset < node.nodeValue.length) {\n      rect = singleRect(textRange(node, offset, offset + 1), -1);\n      side = \"left\";\n    }\n    if ((!rect || rect.left == rect.right) && offset) {\n      rect = singleRect(textRange(node, offset - 1, offset), 1);\n      side = \"right\";\n    }\n  } else if (node.firstChild) {\n    if (offset < node.childNodes.length) {\n      var child = node.childNodes[offset];\n      rect = singleRect(child.nodeType == 3 ? textRange(child) : child, -1);\n      side = \"left\";\n    }\n    if ((!rect || rect.top == rect.bottom) && offset) {\n      var _child = node.childNodes[offset - 1];\n      rect = singleRect(_child.nodeType == 3 ? textRange(_child) : _child, 1);\n      side = \"right\";\n    }\n  } else {\n    rect = node.getBoundingClientRect();\n    side = \"left\";\n  }\n  var x = rect[side];\n  return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\nexports.coordsAtPos = coordsAtPos;","deps":{"../util/dom":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/dom.js"}},"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/selection.js":{"file":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/selection.js","source":"\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = require(\"../util/dom\"),\n    contains = _require.contains;\n\nvar browser = require(\"../util/browser\");\n\nvar _require2 = require(\"./dompos\"),\n    posFromDOM = _require2.posFromDOM,\n    DOMAfterPos = _require2.DOMAfterPos,\n    DOMFromPos = _require2.DOMFromPos,\n    coordsAtPos = _require2.coordsAtPos;\n\n// Track the state of the current editor selection. Keeps the editor\n// selection in sync with the DOM selection by polling for changes,\n// as there is no DOM event for DOM selection changes.\n\n\nvar SelectionState = function () {\n  function SelectionState(pm, range) {\n    var _this = this;\n\n    _classCallCheck(this, SelectionState);\n\n    this.pm = pm;\n    // The current editor selection.\n    this.range = range;\n\n    // The timeout ID for the poller when active.\n    this.polling = null;\n    // Track the state of the DOM selection.\n    this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null;\n    // The corresponding DOM node when a node selection is active.\n    this.lastNode = null;\n\n    pm.content.addEventListener(\"focus\", function () {\n      return _this.receivedFocus();\n    });\n\n    this.poller = this.poller.bind(this);\n  }\n\n  // : (Selection, boolean)\n  // Set the current selection and signal an event on the editor.\n\n\n  _createClass(SelectionState, [{\n    key: \"setAndSignal\",\n    value: function setAndSignal(range, clearLast) {\n      this.set(range, clearLast);\n      this.pm.on.selectionChange.dispatch();\n    }\n\n    // : (Selection, boolean)\n    // Set the current selection.\n\n  }, {\n    key: \"set\",\n    value: function set(range, clearLast) {\n      this.pm.ensureOperation({ readSelection: false, selection: range });\n      this.range = range;\n      if (clearLast !== false) this.lastAnchorNode = null;\n    }\n  }, {\n    key: \"poller\",\n    value: function poller() {\n      if (hasFocus(this.pm)) {\n        if (!this.pm.operation) this.readFromDOM();\n        this.polling = setTimeout(this.poller, 100);\n      } else {\n        this.polling = null;\n      }\n    }\n  }, {\n    key: \"startPolling\",\n    value: function startPolling() {\n      clearTimeout(this.polling);\n      this.polling = setTimeout(this.poller, 50);\n    }\n  }, {\n    key: \"fastPoll\",\n    value: function fastPoll() {\n      this.startPolling();\n    }\n  }, {\n    key: \"stopPolling\",\n    value: function stopPolling() {\n      clearTimeout(this.polling);\n      this.polling = null;\n    }\n\n    // : () → bool\n    // Whether the DOM selection has changed from the last known state.\n\n  }, {\n    key: \"domChanged\",\n    value: function domChanged() {\n      var sel = this.pm.root.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset;\n    }\n\n    // Store the current state of the DOM selection.\n\n  }, {\n    key: \"storeDOMState\",\n    value: function storeDOMState() {\n      var sel = this.pm.root.getSelection();\n      this.lastAnchorNode = sel.anchorNode;this.lastAnchorOffset = sel.anchorOffset;\n      this.lastHeadNode = sel.focusNode;this.lastHeadOffset = sel.focusOffset;\n    }\n\n    // : () → bool\n    // When the DOM selection changes in a notable manner, modify the\n    // current selection state to match.\n\n  }, {\n    key: \"readFromDOM\",\n    value: function readFromDOM() {\n      if (!hasFocus(this.pm) || !this.domChanged()) return false;\n\n      var _selectionFromDOM = selectionFromDOM(this.pm, this.range.head),\n          range = _selectionFromDOM.range,\n          adjusted = _selectionFromDOM.adjusted;\n\n      this.setAndSignal(range);\n\n      if (range instanceof NodeSelection || adjusted) {\n        this.toDOM();\n      } else {\n        this.clearNode();\n        this.storeDOMState();\n      }\n      return true;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM(takeFocus) {\n      if (!hasFocus(this.pm)) {\n        if (!takeFocus) return;\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444\n        else if (browser.gecko) this.pm.content.focus();\n      }\n      if (this.range instanceof NodeSelection) this.nodeToDOM();else this.rangeToDOM();\n    }\n\n    // Make changes to the DOM for a node selection.\n\n  }, {\n    key: \"nodeToDOM\",\n    value: function nodeToDOM() {\n      var dom = DOMAfterPos(this.pm, this.range.from);\n      if (dom != this.lastNode) {\n        this.clearNode();\n        dom.classList.add(\"ProseMirror-selectednode\");\n        this.pm.content.classList.add(\"ProseMirror-nodeselection\");\n        this.lastNode = dom;\n      }\n      var range = document.createRange(),\n          sel = this.pm.root.getSelection();\n      range.selectNode(dom);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      this.storeDOMState();\n    }\n\n    // Make changes to the DOM for a text selection.\n\n  }, {\n    key: \"rangeToDOM\",\n    value: function rangeToDOM() {\n      this.clearNode();\n\n      var anchor = DOMFromPos(this.pm, this.range.anchor);\n      var head = DOMFromPos(this.pm, this.range.head);\n\n      var sel = this.pm.root.getSelection(),\n          range = document.createRange();\n      if (sel.extend) {\n        range.setEnd(anchor.node, anchor.offset);\n        range.collapse(false);\n      } else {\n        if (this.range.anchor > this.range.head) {\n          var tmp = anchor;anchor = head;head = tmp;\n        }\n        range.setEnd(head.node, head.offset);\n        range.setStart(anchor.node, anchor.offset);\n      }\n      sel.removeAllRanges();\n      sel.addRange(range);\n      if (sel.extend) sel.extend(head.node, head.offset);\n      this.storeDOMState();\n    }\n\n    // Clear all DOM statefulness of the last node selection.\n\n  }, {\n    key: \"clearNode\",\n    value: function clearNode() {\n      if (this.lastNode) {\n        this.lastNode.classList.remove(\"ProseMirror-selectednode\");\n        this.pm.content.classList.remove(\"ProseMirror-nodeselection\");\n        this.lastNode = null;\n        return true;\n      }\n    }\n  }, {\n    key: \"receivedFocus\",\n    value: function receivedFocus() {\n      if (this.polling == null) this.startPolling();\n    }\n  }]);\n\n  return SelectionState;\n}();\n\nexports.SelectionState = SelectionState;\n\n// ;; An editor selection. Can be one of two selection types:\n// `TextSelection` or `NodeSelection`. Both have the properties\n// listed here, but also contain more information (such as the\n// selected [node](#NodeSelection.node) or the\n// [head](#TextSelection.head) and [anchor](#TextSelection.anchor)).\n\nvar Selection = function () {\n  _createClass(Selection, [{\n    key: \"from\",\n\n    // :: number\n    // The left bound of the selection.\n    get: function get() {\n      return this.$from.pos;\n    }\n\n    // :: number\n    // The right bound of the selection.\n\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.$to.pos;\n    }\n  }]);\n\n  function Selection($from, $to) {\n    _classCallCheck(this, Selection);\n\n    // :: ResolvedPos\n    // The resolved left bound of the selection\n    this.$from = $from;\n    // :: ResolvedPos\n    // The resolved right bound of the selection\n    this.$to = $to;\n  }\n\n  // :: bool\n  // True if the selection is an empty text selection (head an anchor\n  // are the same).\n\n\n  _createClass(Selection, [{\n    key: \"empty\",\n    get: function get() {\n      return this.from == this.to;\n    }\n\n    // :: (other: Selection) → bool #path=Selection.prototype.eq\n    // Test whether the selection is the same as another selection.\n\n    // :: (doc: Node, mapping: Mappable) → Selection #path=Selection.prototype.map\n    // Map this selection through a [mappable](#Mappable) thing. `doc`\n    // should be the new document, to which we are mapping.\n\n  }]);\n\n  return Selection;\n}();\n\nexports.Selection = Selection;\n\n// ;; A text selection represents a classical editor\n// selection, with a head (the moving side) and anchor (immobile\n// side), both of which point into textblock nodes. It can be empty (a\n// regular cursor position).\n\nvar TextSelection = function (_Selection) {\n  _inherits(TextSelection, _Selection);\n\n  _createClass(TextSelection, [{\n    key: \"anchor\",\n\n    // :: number\n    // The selection's immobile side (does not move when pressing\n    // shift-arrow).\n    get: function get() {\n      return this.$anchor.pos;\n    }\n    // :: number\n    // The selection's mobile side (the side that moves when pressing\n    // shift-arrow).\n\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this.$head.pos;\n    }\n\n    // :: (ResolvedPos, ?ResolvedPos)\n    // Construct a text selection. When `head` is not given, it defaults\n    // to `anchor`.\n\n  }]);\n\n  function TextSelection($anchor) {\n    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;\n\n    _classCallCheck(this, TextSelection);\n\n    var inv = $anchor.pos > $head.pos;\n\n    // :: ResolvedPos The resolved anchor of the selection.\n    var _this2 = _possibleConstructorReturn(this, (TextSelection.__proto__ || Object.getPrototypeOf(TextSelection)).call(this, inv ? $head : $anchor, inv ? $anchor : $head));\n\n    _this2.$anchor = $anchor;\n    // :: ResolvedPos The resolved head of the selection.\n    _this2.$head = $head;\n    return _this2;\n  }\n\n  _createClass(TextSelection, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof TextSelection && other.head == this.head && other.anchor == this.anchor;\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var $head = doc.resolve(mapping.map(this.head));\n      if (!$head.parent.isTextblock) return findSelectionNear($head);\n      var $anchor = doc.resolve(mapping.map(this.anchor));\n      return new TextSelection($anchor.parent.isTextblock ? $anchor : $head, $head);\n    }\n  }, {\n    key: \"inverted\",\n    get: function get() {\n      return this.anchor > this.head;\n    }\n  }, {\n    key: \"token\",\n    get: function get() {\n      return new SelectionToken(TextSelection, this.anchor, this.head);\n    }\n  }], [{\n    key: \"mapToken\",\n    value: function mapToken(token, mapping) {\n      return new SelectionToken(TextSelection, mapping.map(token.a), mapping.map(token.b));\n    }\n  }, {\n    key: \"fromToken\",\n    value: function fromToken(token, doc) {\n      var $head = doc.resolve(token.b);\n      if (!$head.parent.isTextblock) return findSelectionNear($head);\n      var $anchor = doc.resolve(token.a);\n      return new TextSelection($anchor.parent.isTextblock ? $anchor : $head, $head);\n    }\n  }]);\n\n  return TextSelection;\n}(Selection);\n\nexports.TextSelection = TextSelection;\n\n// ;; A node selection is a selection that points at a\n// single node. All nodes marked [selectable](#NodeType.selectable)\n// can be the target of a node selection. In such an object, `from`\n// and `to` point directly before and after the selected node.\n\nvar NodeSelection = function (_Selection2) {\n  _inherits(NodeSelection, _Selection2);\n\n  // :: (ResolvedPos)\n  // Create a node selection. Does not verify the validity of its\n  // argument. Use `ProseMirror.setNodeSelection` for an easier,\n  // error-checking way to create a node selection.\n  function NodeSelection($from) {\n    _classCallCheck(this, NodeSelection);\n\n    var $to = $from.plusOne();\n\n    // :: Node The selected node.\n    var _this3 = _possibleConstructorReturn(this, (NodeSelection.__proto__ || Object.getPrototypeOf(NodeSelection)).call(this, $from, $to));\n\n    _this3.node = $from.nodeAfter;\n    return _this3;\n  }\n\n  _createClass(NodeSelection, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof NodeSelection && this.from == other.from;\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var $from = doc.resolve(mapping.map(this.from, 1));\n      var to = mapping.map(this.to, -1);\n      var node = $from.nodeAfter;\n      if (node && to == $from.pos + node.nodeSize && node.type.selectable) return new NodeSelection($from);\n      return findSelectionNear($from);\n    }\n  }, {\n    key: \"token\",\n    get: function get() {\n      return new SelectionToken(NodeSelection, this.from, this.to);\n    }\n  }], [{\n    key: \"mapToken\",\n    value: function mapToken(token, mapping) {\n      return new SelectionToken(NodeSelection, mapping.map(token.a, 1), mapping.map(token.b, -1));\n    }\n  }, {\n    key: \"fromToken\",\n    value: function fromToken(token, doc) {\n      var $from = doc.resolve(token.a),\n          node = $from.nodeAfter;\n      if (node && token.b == token.a + node.nodeSize && node.type.selectable) return new NodeSelection($from);\n      return findSelectionNear($from);\n    }\n  }]);\n\n  return NodeSelection;\n}(Selection);\n\nexports.NodeSelection = NodeSelection;\n\nvar SelectionToken = function SelectionToken(type, a, b) {\n  _classCallCheck(this, SelectionToken);\n\n  this.type = type;\n  this.a = a;\n  this.b = b;\n};\n\nfunction isCollapsed(sel) {\n  // Selection.isCollapsed is broken in Chrome 52.\n  // See https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n  return sel.focusNode === sel.anchorNode && sel.focusOffset === sel.anchorOffset;\n}\nexports.isCollapsed = isCollapsed;\n\nfunction selectionFromDOM(pm, oldHead) {\n  var sel = pm.root.getSelection();\n  var doc = pm.doc;\n\n  var _posFromDOM = posFromDOM(sel.focusNode, sel.focusOffset),\n      head = _posFromDOM.pos,\n      headLeaf = _posFromDOM.inLeaf;\n\n  if (headLeaf > -1 && isCollapsed(sel)) {\n    var $leaf = doc.resolve(headLeaf),\n        node = $leaf.nodeAfter;\n    if (node.type.selectable && !node.type.isInline) return { range: new NodeSelection($leaf), adjusted: true };\n  }\n  var anchor = isCollapsed(sel) ? head : posFromDOM(sel.anchorNode, sel.anchorOffset).pos;\n\n  var range = findSelectionNear(doc.resolve(head), oldHead != null && oldHead < head ? 1 : -1);\n  if (range instanceof TextSelection) {\n    var selNearAnchor = findSelectionNear(doc.resolve(anchor), anchor > range.to ? -1 : 1, true);\n    range = new TextSelection(selNearAnchor.$anchor, range.$head);\n  } else if (anchor < range.from || anchor > range.to) {\n    // If head falls on a node, but anchor falls outside of it,\n    // create a text selection between them\n    var inv = anchor > range.to;\n    range = new TextSelection(findSelectionNear(doc.resolve(anchor), inv ? -1 : 1, true).$anchor, findSelectionNear(inv ? range.$from : range.$to, inv ? 1 : -1, true).$head);\n  }\n  return { range: range, adjusted: head != range.head || anchor != range.anchor };\n}\n\nfunction hasFocus(pm) {\n  if (pm.root.activeElement != pm.content) return false;\n  var sel = pm.root.getSelection();\n  return sel.rangeCount && contains(pm.content, sel.anchorNode);\n}\nexports.hasFocus = hasFocus;\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.isTextblock) return new TextSelection(doc.resolve(pos));\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.type.isLeaf) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) return inner;\n    } else if (!text && child.type.selectable) {\n      return new NodeSelection(doc.resolve(pos - (dir < 0 ? child.nodeSize : 0)));\n    }\n    pos += child.nodeSize * dir;\n  }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Create a selection which is moved relative to a position in a\n// given direction. When a selection isn't found at the given position,\n// walks up the document tree one level and one step in the\n// desired direction.\nfunction findSelectionFrom($pos, dir, text) {\n  var inner = $pos.parent.isTextblock ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, text);\n  if (inner) return inner;\n\n  for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n    var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, text) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, text);\n    if (found) return found;\n  }\n}\nexports.findSelectionFrom = findSelectionFrom;\n\nfunction findSelectionNear($pos) {\n  var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var text = arguments[2];\n\n  var result = findSelectionFrom($pos, bias, text) || findSelectionFrom($pos, -bias, text);\n  if (!result) throw new RangeError(\"Searching for selection in invalid document \" + $pos.node(0));\n  return result;\n}\nexports.findSelectionNear = findSelectionNear;\n\n// Find the selection closest to the start of the given node. `pos`,\n// if given, should point at the start of the node's content.\nfunction findSelectionAtStart(doc, text) {\n  return findSelectionIn(doc, doc, 0, 0, 1, text);\n}\nexports.findSelectionAtStart = findSelectionAtStart;\n\n// Find the selection closest to the end of the given node.\nfunction findSelectionAtEnd(doc, text) {\n  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1, text);\n}\nexports.findSelectionAtEnd = findSelectionAtEnd;\n\n// : (ProseMirror, number, number)\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction verticalMotionLeavesTextblock(pm, $pos, dir) {\n  var dom = $pos.depth ? DOMAfterPos(pm, $pos.before()) : pm.content;\n  var coords = coordsAtPos(pm, $pos.pos);\n  for (var child = dom.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType != 1) continue;\n    var boxes = child.getClientRects();\n    for (var i = 0; i < boxes.length; i++) {\n      var box = boxes[i];\n      if (dir < 0 ? box.bottom < coords.top : box.top > coords.bottom) return false;\n    }\n  }\n  return true;\n}\nexports.verticalMotionLeavesTextblock = verticalMotionLeavesTextblock;","deps":{"../util/browser":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/browser.js","../util/dom":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/dom.js","./dompos":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/dompos.js"}},"/home/kassawat/fiduswriter-develop/es6-cache/test-caret.es6.js":{"file":"/home/kassawat/fiduswriter-develop/es6-cache/test-caret.es6.js","source":"\"use strict\";\n\nvar _selection = require(\"prosemirror-old/dist/edit/selection\");\n\n/**\n * Helper functions for testing FidusWriter with Selenium.\n * @namespace testCaret\n */\nvar testCaret = {};\n\n/**\n * Returns the current selection.\n * @function getCaret\n * @memberof testCaret\n * @returns {Caret}\n */\ntestCaret.getCaret = function getCaret() {\n  return window.theEditor.pm.selection.from;\n};\n\n/**\n * Sets an empty selection to caret.\n * @function setCaret\n * @memberof testCaret\n * @param {Selection} caret Selection.\n * @returns {Selection}\n */\ntestCaret.setCaret = function setCaret(caret) {\n  return testCaret.setSelection(caret, caret);\n};\n\n/**\n * Sets the selection to be between two caret positions.\n * @function setSelection\n * @memberof testCaret\n * @param {caretOne} caretOne The first caret.\n * @param {caretTwo} caretTwo The second caret position.\n * @returns {Selection}\n */\ntestCaret.setSelection = function setSelection(caretOne, caretTwo) {\n  var caretOneRes = window.theEditor.pm.doc.resolve(caretOne);\n  var caretTwoRes = window.theEditor.pm.doc.resolve(caretTwo);\n  var selection = new _selection.TextSelection(caretOneRes, caretTwoRes);\n\n  window.theEditor.pm.setSelection(selection);\n  window.theEditor.pm.focus();\n\n  return selection;\n};\n\n/**\n * Checks if the given selections are equal.\n * @function caretsMatch\n * @memberof testCaret\n * @param {Selection} left Caret to be compared.\n * @param {Selection} right Caret to be compared.\n * @returns {Boolean}\n */\ntestCaret.selectionsMatch = function selectionsMatch(left, right) {\n  return left.eq(right);\n};\n\nwindow.testCaret = testCaret;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QtY2FyZXQuZXM2LmpzIl0sIm5hbWVzIjpbIlRleHRTZWxlY3Rpb24iLCJ0ZXN0Q2FyZXQiLCJnZXRDYXJldCIsIndpbmRvdyIsInRoZUVkaXRvciIsInBtIiwic2VsZWN0aW9uIiwiZnJvbSIsInNldENhcmV0IiwiY2FyZXQiLCJzZXRTZWxlY3Rpb24iLCJjYXJldE9uZSIsImNhcmV0VHdvIiwiY2FyZXRPbmVSZXMiLCJkb2MiLCJyZXNvbHZlIiwiY2FyZXRUd29SZXMiLCJmb2N1cyIsInNlbGVjdGlvbnNNYXRjaCIsImxlZnQiLCJyaWdodCIsImVxIl0sIm1hcHBpbmdzIjoiOztBQUFBLEFBQVEsQUFBUixBQUE0QixBQUE1Qjs7QUFDQTs7OztBQUlBLElBQUksWUFBWSxBQUFoQjs7QUFHQTs7Ozs7O0FBTUEsVUFBVSxBQUFWLFdBQXFCLFNBQVMsQUFBVCxXQUFvQixBQUNyQztTQUFPLE9BQU8sQUFBUCxVQUFpQixBQUFqQixHQUFvQixBQUFwQixVQUE4QixBQUFyQyxBQUNIO0FBRkQ7O0FBSUE7Ozs7Ozs7QUFPQSxVQUFVLEFBQVYsV0FBcUIsU0FBUyxBQUFULFNBQWtCLEFBQWxCLE9BQXlCLEFBQzFDO1NBQU8sVUFBVSxBQUFWLGFBQXVCLEFBQXZCLE9BQThCLEFBQTlCLEFBQVAsQUFDSDtBQUZEOztBQUlBOzs7Ozs7OztBQVFBLFVBQVUsQUFBVixlQUF5QixTQUFTLEFBQVQsYUFBc0IsQUFBdEIsVUFBZ0MsQUFBaEMsVUFBMEMsQUFDL0Q7TUFBSSxjQUFjLE9BQU8sQUFBUCxVQUFpQixBQUFqQixHQUFvQixBQUFwQixJQUF3QixBQUF4QixRQUFnQyxBQUFoQyxBQUFsQixBQUNBO01BQUksY0FBYyxPQUFPLEFBQVAsVUFBaUIsQUFBakIsR0FBb0IsQUFBcEIsSUFBd0IsQUFBeEIsUUFBZ0MsQUFBaEMsQUFBbEIsQUFDQTtNQUFJLFlBQVksQUFBSSxBQUFKLDZCQUFrQixBQUFsQixhQUErQixBQUEvQixBQUFoQixBQUVBOztTQUFPLEFBQVAsVUFBaUIsQUFBakIsR0FBb0IsQUFBcEIsYUFBaUMsQUFBakMsQUFDQTtTQUFPLEFBQVAsVUFBaUIsQUFBakIsR0FBb0IsQUFBcEIsQUFFQTs7U0FBTyxBQUFQLEFBQ0g7QUFURDs7QUFXQTs7Ozs7Ozs7QUFRQSxVQUFVLEFBQVYsa0JBQTRCLFNBQVMsQUFBVCxnQkFBeUIsQUFBekIsTUFBK0IsQUFBL0IsT0FBc0MsQUFDOUQ7U0FBTyxLQUFLLEFBQUwsR0FBUSxBQUFSLEFBQVAsQUFDSDtBQUZEOztBQUlBLE9BQU8sQUFBUCxZQUFtQixBQUFuQiIsImZpbGUiOiJ0ZXN0LWNhcmV0LmVzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VGV4dFNlbGVjdGlvbn0gZnJvbSBcInByb3NlbWlycm9yLW9sZC9kaXN0L2VkaXQvc2VsZWN0aW9uXCJcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGVzdGluZyBGaWR1c1dyaXRlciB3aXRoIFNlbGVuaXVtLlxuICogQG5hbWVzcGFjZSB0ZXN0Q2FyZXRcbiAqL1xubGV0IHRlc3RDYXJldCA9IHt9XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEBmdW5jdGlvbiBnZXRDYXJldFxuICogQG1lbWJlcm9mIHRlc3RDYXJldFxuICogQHJldHVybnMge0NhcmV0fVxuICovXG50ZXN0Q2FyZXQuZ2V0Q2FyZXQgPSBmdW5jdGlvbiBnZXRDYXJldCgpIHtcbiAgICByZXR1cm4gd2luZG93LnRoZUVkaXRvci5wbS5zZWxlY3Rpb24uZnJvbVxufVxuXG4vKipcbiAqIFNldHMgYW4gZW1wdHkgc2VsZWN0aW9uIHRvIGNhcmV0LlxuICogQGZ1bmN0aW9uIHNldENhcmV0XG4gKiBAbWVtYmVyb2YgdGVzdENhcmV0XG4gKiBAcGFyYW0ge1NlbGVjdGlvbn0gY2FyZXQgU2VsZWN0aW9uLlxuICogQHJldHVybnMge1NlbGVjdGlvbn1cbiAqL1xudGVzdENhcmV0LnNldENhcmV0ID0gZnVuY3Rpb24gc2V0Q2FyZXQoY2FyZXQpIHtcbiAgICByZXR1cm4gdGVzdENhcmV0LnNldFNlbGVjdGlvbihjYXJldCwgY2FyZXQpXG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0aW9uIHRvIGJlIGJldHdlZW4gdHdvIGNhcmV0IHBvc2l0aW9ucy5cbiAqIEBmdW5jdGlvbiBzZXRTZWxlY3Rpb25cbiAqIEBtZW1iZXJvZiB0ZXN0Q2FyZXRcbiAqIEBwYXJhbSB7Y2FyZXRPbmV9IGNhcmV0T25lIFRoZSBmaXJzdCBjYXJldC5cbiAqIEBwYXJhbSB7Y2FyZXRUd299IGNhcmV0VHdvIFRoZSBzZWNvbmQgY2FyZXQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7U2VsZWN0aW9ufVxuICovXG50ZXN0Q2FyZXQuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGNhcmV0T25lLCBjYXJldFR3bykge1xuICAgIGxldCBjYXJldE9uZVJlcyA9IHdpbmRvdy50aGVFZGl0b3IucG0uZG9jLnJlc29sdmUoY2FyZXRPbmUpXG4gICAgbGV0IGNhcmV0VHdvUmVzID0gd2luZG93LnRoZUVkaXRvci5wbS5kb2MucmVzb2x2ZShjYXJldFR3bylcbiAgICBsZXQgc2VsZWN0aW9uID0gbmV3IFRleHRTZWxlY3Rpb24oY2FyZXRPbmVSZXMsIGNhcmV0VHdvUmVzKVxuXG4gICAgd2luZG93LnRoZUVkaXRvci5wbS5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgIHdpbmRvdy50aGVFZGl0b3IucG0uZm9jdXMoKVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvblxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc2VsZWN0aW9ucyBhcmUgZXF1YWwuXG4gKiBAZnVuY3Rpb24gY2FyZXRzTWF0Y2hcbiAqIEBtZW1iZXJvZiB0ZXN0Q2FyZXRcbiAqIEBwYXJhbSB7U2VsZWN0aW9ufSBsZWZ0IENhcmV0IHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHtTZWxlY3Rpb259IHJpZ2h0IENhcmV0IHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbnRlc3RDYXJldC5zZWxlY3Rpb25zTWF0Y2ggPSBmdW5jdGlvbiBzZWxlY3Rpb25zTWF0Y2gobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC5lcShyaWdodClcbn1cblxud2luZG93LnRlc3RDYXJldCA9IHRlc3RDYXJldFxuIl19","deps":{"prosemirror-old/dist/edit/selection":"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/selection.js"}}},"mtimes":{"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/browser.js":1483456169000,"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/util/dom.js":1483456169000,"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/dompos.js":1483456164000,"/home/kassawat/fiduswriter-develop/node_modules/prosemirror-old/dist/edit/selection.js":1483456165000,"/home/kassawat/fiduswriter-develop/es6-cache/test-caret.es6.js":1485131707916},"dependentFiles":{}}