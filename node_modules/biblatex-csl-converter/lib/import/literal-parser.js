'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BibLatexLiteralParser = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LATEX_COMMANDS = [// commands that can can contain richtext.
['\\textbf{', 'strong'], ['\\mkbibbold{', 'strong'], ['\\mkbibitalic{', 'em'], ['\\mkbibemph{', 'em'], ['\\textit{', 'em'], ['\\emph{', 'em'], ['\\textsc{', 'smallcaps'], ['\\enquote{', 'enquote'], ['\\textsubscript{', 'sub'], ['\\textsuperscript{', 'sup']];

var LATEX_VERBATIM_COMMANDS = [// commands that can only contain plaintext.
['\\url{', 'url']];

var LATEX_SPECIAL_CHARS = {
    '&': '&',
    '%': '%',
    '$': '$',
    '#': '#',
    '_': '_',
    '{': '{',
    '}': '}',
    ',': ',',
    '~': '~',
    '^': '^',
    '\'': '\'',
    ';': '\u2004'
};

var BibLatexLiteralParser = exports.BibLatexLiteralParser = function () {
    function BibLatexLiteralParser(string) {
        var cpMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        (0, _classCallCheck3.default)(this, BibLatexLiteralParser);

        this.string = string;
        this.cpMode = cpMode; // Whether to consider case preservation.
        this.braceLevel = 0;
        this.slen = string.length;
        this.si = 0; // string index
        this.json = [];
        this.braceClosings = [];
        this.currentMarks = [];
        this.inCasePreserve = false;
        this.textNode = false;
    }

    // If the last text node has no content, remove it.


    (0, _createClass3.default)(BibLatexLiteralParser, [{
        key: 'removeIfEmptyTextNode',
        value: function removeIfEmptyTextNode() {
            if (this.textNode.text.length === 0) {
                this.json.pop();
            }
        }
    }, {
        key: 'checkAndAddNewTextNode',
        value: function checkAndAddNewTextNode() {
            if (this.textNode.text.length > 0) {
                // We have text in the last node already,
                // so we need to start a new text node.
                this.addNewTextNode();
            }
        }
    }, {
        key: 'addNewTextNode',
        value: function addNewTextNode() {
            this.textNode = { type: 'text', text: '' };
            this.json.push(this.textNode);
        }
    }, {
        key: 'stringParser',
        value: function stringParser() {
            this.addNewTextNode();

            parseString: while (this.si < this.slen) {
                switch (this.string[this.si]) {
                    case '\\':
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = (0, _getIterator3.default)(LATEX_COMMANDS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var command = _step.value;

                                if (this.string.substring(this.si, this.si + command[0].length) === command[0]) {
                                    this.braceLevel++;
                                    this.si += command[0].length;
                                    this.checkAndAddNewTextNode();
                                    if (this.cpMode) {
                                        // If immediately inside a brace that added case protection, remove case protection. See
                                        // http://tex.stackexchange.com/questions/276943/biblatex-how-to-emphasize-but-not-caps-protect
                                        if (this.inCasePreserve === this.braceLevel - 1 && this.string[this.si - 1] === '{' && this.currentMarks[this.currentMarks.length - 1].type === 'nocase') {
                                            this.currentMarks.pop();
                                            this.inCasePreserve = false;
                                        } else {
                                            // Of not immediately inside a brace, any styling also
                                            // adds case protection.
                                            this.currentMarks.push({ type: 'nocase' });
                                            this.inCasePreserve = this.braceLevel;
                                        }
                                    }
                                    this.currentMarks.push({ type: command[1] });
                                    this.textNode.marks = this.currentMarks.slice();
                                    this.braceClosings.push(true);
                                    continue parseString;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = (0, _getIterator3.default)(LATEX_VERBATIM_COMMANDS), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var _command = _step2.value;

                                if (this.string.substring(this.si, this.si + _command[0].length) === _command[0]) {
                                    this.checkAndAddNewTextNode();
                                    this.textNode.marks = this.currentMarks.slice();
                                    this.textNode.marks.push({ type: _command[1] });
                                    this.si += _command[0].length;
                                    var _sj = this.si;
                                    var internalBraceLevel = 0;
                                    while (_sj < this.slen && (this.string[_sj] !== '}' || internalBraceLevel > 0)) {
                                        switch (this.string[_sj]) {
                                            case '{':
                                                internalBraceLevel++;
                                                break;
                                            case '}':
                                                internalBraceLevel--;
                                                break;
                                        }
                                        _sj++;
                                    }
                                    this.textNode.text = this.string.substring(this.si, _sj);
                                    this.addNewTextNode();
                                    this.si = _sj + 1;
                                    continue parseString;
                                }
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        if (LATEX_SPECIAL_CHARS[this.string[this.si + 1]]) {
                            this.textNode.text += LATEX_SPECIAL_CHARS[this.string[this.si + 1]];
                            this.si += 2;
                        } else {
                            // We don't know the command and skip it.
                            this.si++;
                            while (this.si < this.slen && this.string[this.si].match("[a-zA-Z0-9]")) {
                                this.si++;
                            }
                            // If there is a brace at the end of the command,
                            // increase brace level but ignore brace.
                            if (this.string[this.si] === "{") {
                                this.braceLevel++;
                                this.braceClosings.push(false);
                                this.si++;
                            }
                        }
                        break;
                    case '_':
                        switch (this.string[this.si + 1]) {
                            case '{':
                                this.checkAndAddNewTextNode();
                                this.braceLevel++;
                                this.si += 2;
                                this.currentMarks.push({ type: 'sub' });
                                this.textNode.marks = this.currentMarks.slice();
                                this.braceClosings.push(true);
                                break;
                            case '\\':
                                // There is a command following directly. Ignore the sub symbol.
                                this.si++;
                                break;
                            default:
                                // We only add the next character to a sub node.
                                this.checkAndAddNewTextNode();
                                this.textNode.marks = this.currentMarks.slice();
                                this.textNode.marks.push({ type: 'sub' });
                                this.textNode.text = this.string[this.si + 1];
                                this.addNewTextNode();
                                this.si += 2;
                        }
                        break;
                    case '^':
                        switch (this.string[this.si + 1]) {
                            case '{':
                                this.checkAndAddNewTextNode();
                                this.braceLevel++;
                                this.si += 2;
                                this.currentMarks.push({ type: 'sup' });
                                this.textNode.marks = this.currentMarks.slice();
                                this.braceClosings.push(true);
                                break;
                            case '\\':
                                // There is a command following directly. Ignore the sup symbol.
                                this.si++;
                                break;
                            default:
                                // We only add the next character to a sup node.
                                this.checkAndAddNewTextNode();
                                this.textNode.marks = this.currentMarks.slice();
                                this.textNode.marks.push({ type: 'sup' });
                                this.textNode.text = this.string[this.si + 1];
                                this.addNewTextNode();
                                this.si += 2;
                        }
                        break;
                    case '{':
                        this.braceLevel++;
                        if (this.inCasePreserve || !this.cpMode) {
                            // If already inside case preservation, do not add a second
                            this.braceClosings.push(false);
                        } else {
                            this.inCasePreserve = this.braceLevel;
                            this.checkAndAddNewTextNode();
                            this.currentMarks.push({ type: 'nocase' });
                            this.textNode.marks = this.currentMarks.slice();
                            this.braceClosings.push(true);
                        }
                        this.si++;
                        break;
                    case '}':
                        this.braceLevel--;
                        if (this.braceLevel > -1) {
                            var closeBrace = this.braceClosings.pop();
                            if (closeBrace) {
                                this.checkAndAddNewTextNode();
                                var lastMark = this.currentMarks.pop();
                                if (this.inCasePreserve === this.braceLevel + 1) {
                                    this.inCasePreserve = false;
                                    // The last tag may have added more tags. The
                                    // lowest level will be the case preserving one.
                                    while (lastMark.type !== 'nocase' && this.currentMarks.length) {
                                        lastMark = this.currentMarks.pop();
                                    }
                                }
                                if (this.currentMarks.length) {
                                    this.textNode.marks = this.currentMarks.slice();
                                }
                            }
                            this.si++;
                            continue parseString;
                        } else {
                            // A brace was closed before it was opened. Abort and return the original string.
                            return [{ type: 'text', text: this.string }];
                        }
                        break;
                    case '$':
                        // math env, just remove
                        this.si++;
                        break;
                    case '~':
                        // a non-breakable space
                        this.textNode.text += '\xA0';
                        this.si++;
                        break;
                    case '%':
                        // An undefined variable.
                        this.removeIfEmptyTextNode();
                        var sj = this.si + 1;
                        while (sj < this.slen && this.string[sj] !== '%') {
                            sj++;
                        }
                        var variable = this.string.substring(this.si + 1, sj);
                        this.json.push({ type: 'variable', attrs: { variable: variable } });
                        this.addNewTextNode();
                        this.si = sj + 1;
                        break;
                    case '\r':
                        this.si++;
                        break;
                    case '\n':
                        if (['\r', '\n'].includes(this.string[this.si + 1]) || this.textNode.text.length && this.textNode.text[this.textNode.text.length - 1] === '\n') {
                            this.textNode.text += '\n';
                        } else {
                            this.textNode.text += ' ';
                        }
                        this.si++;
                        break;
                    default:
                        this.textNode.text += this.string[this.si];
                        this.si++;
                }
            }

            if (this.braceLevel > 0) {
                // Too many opening braces, we return the original string.
                return [{ type: 'text', text: this.string }];
            }

            this.removeIfEmptyTextNode();

            // Braces were accurate.
            return this.json;
        }
    }, {
        key: 'output',
        get: function get() {
            return this.stringParser();
        }
    }]);
    return BibLatexLiteralParser;
}();