"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CSLExporter = undefined;

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _const = require("../const");

var _edtf = require("../edtf");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Converts a BibDB to a DB of the CSL type.
 * @param bibDB The bibliography database to convert.
 */

var TAGS = {
    'strong': { open: '<b>', close: '</b>' },
    'em': { open: '<i>', close: '</i>' },
    'sub': { open: '<sub>', close: '</sub>' },
    'sup': { open: '<sup>', close: '</sup>' },
    'smallcaps': { open: '<span style="font-variant:small-caps;">', close: '</span>' },
    'nocase': { open: '<span class="nocase">', close: '</span>' },
    'enquote': { open: '“', close: '”' },
    'url': { open: '', close: '' },
    'undefined': { open: '[', close: ']' }
};

var CSLExporter = exports.CSLExporter = function () {
    function CSLExporter(bibDB, pks) {
        (0, _classCallCheck3.default)(this, CSLExporter);

        this.bibDB = bibDB;
        if (pks) {
            this.pks = pks; // A list of pk values of the bibliography items to be exported.
        } else {
            this.pks = (0, _keys2.default)(bibDB); // If none are selected, all keys are exporter
        }
        this.cslDB = {};
        this.errors = [];
    }

    (0, _createClass3.default)(CSLExporter, [{
        key: "getCSLEntry",

        /** Converts one BibDB entry to CSL format.
         * @function getCSLEntry
         * @param id The id identifying the bibliography entry.
         */
        value: function getCSLEntry(id) {
            var _this = this;

            var that = this,
                bib = this.bibDB[id],
                fValues = {};

            var _loop = function _loop(fKey) {
                if (bib.fields[fKey] !== '' && fKey in _const.BibFieldTypes && 'csl' in _const.BibFieldTypes[fKey]) {
                    var fValue = bib.fields[fKey];
                    var fType = _const.BibFieldTypes[fKey]['type'];
                    var key = _const.BibFieldTypes[fKey]['csl'];

                    (function () {
                        switch (fType) {
                            case 'f_date':
                                fValues[key] = _this._reformDate(fValue);
                                break;
                            case 'f_integer':
                                fValues[key] = _this._reformInteger(fValue);
                                break;
                            case 'f_key':
                                fValues[key] = _this._reformKey(fValue, fKey);
                                break;
                            case 'f_literal':
                            case 'f_long_literal':
                                fValues[key] = _this._reformText(fValue);
                                break;
                            case 'l_range':
                                fValues[key] = _this._reformRange(fValue);
                                break;
                            case 'f_title':
                                fValues[key] = _this._reformText(fValue);
                                break;
                            case 'f_uri':
                            case 'f_verbatim':
                                fValues[key] = fValue;
                                break;
                            case 'l_key':
                                fValues[key] = fValue.map(function (key) {
                                    return that._reformKey(key, fKey);
                                }).join(' and ');
                                break;
                            case 'l_literal':
                                var reformedTexts = [];
                                fValue.forEach(function (text) {
                                    reformedTexts.push(that._reformText(text));
                                });
                                fValues[key] = reformedTexts.join(', ');
                                break;
                            case 'l_name':
                                fValues[key] = _this._reformName(fValue);
                                break;
                            case 'l_tag':
                                fValues[key] = fValue.join(', ');
                                break;
                            default:
                                console.warn("Unrecognized type: " + fType + "!");
                        }
                    })();
                }
            };

            for (var fKey in bib.fields) {
                _loop(fKey);
            }
            fValues['type'] = _const.BibTypes[bib.bib_type].csl;
            return fValues;
        }
    }, {
        key: "_reformKey",
        value: function _reformKey(theValue, fKey) {
            if (typeof theValue === 'string') {
                var fieldType = _const.BibFieldTypes[fKey];
                if (Array.isArray(fieldType['options'])) {
                    return theValue;
                } else {
                    return fieldType['options'][theValue]['csl'];
                }
            } else {
                return this._reformText(theValue);
            }
        }
    }, {
        key: "_reformRange",
        value: function _reformRange(theValue) {
            var _this2 = this;

            var that = this;
            return theValue.map(function (range) {
                return range.map(function (text) {
                    return _this2._reformText(text);
                }).join('--');
            }).join(',');
        }
    }, {
        key: "_reformInteger",
        value: function _reformInteger(theValue) {
            var theString = this._reformText(theValue);
            var theInt = parseInt(theString);
            if (theString !== String(theInt)) {
                return theString;
            }
            return theInt;
        }
    }, {
        key: "_reformText",
        value: function _reformText(theValue) {
            var _this3 = this;

            var that = this,
                html = '',
                lastMarks = [];
            theValue.forEach(function (node) {
                if (node.type === 'variable') {
                    // This is an undefined variable
                    // This should usually not happen, as CSL doesn't know what to
                    // do with these. We'll put them into an unsupported tag.
                    html += "" + TAGS.undefined.open + node.attrs.variable + TAGS.undefined.close;
                    _this3.errors.push({
                        type: 'undefined_variable',
                        variable: node.attrs.variable
                    });
                    return;
                }
                var newMarks = [];
                if (node.marks) {
                    node.marks.forEach(function (mark) {
                        newMarks.push(mark.type);
                    });
                }
                // close all tags that are not present in current text node.
                // Go through last marksd in reverse order to close innermost tags first.
                var closing = false;
                lastMarks.slice().reverse().forEach(function (mark, rIndex) {
                    var index = lastMarks.length - rIndex;
                    if (mark != newMarks[index]) {
                        closing = true;
                    }
                    if (closing) {
                        html += TAGS[mark].close;
                    }
                });
                // open all new tags that were not present in the last text node.
                var opening = false;
                newMarks.forEach(function (mark, index) {
                    if (mark != lastMarks[index]) {
                        opening = true;
                    }
                    if (opening) {
                        html += TAGS[mark].open;
                    }
                });
                html += node.text;
                lastMarks = newMarks;
            });
            // Close all still open tags
            lastMarks.slice().reverse().forEach(function (mark) {
                html += TAGS[mark].close;
            });
            return html;
        }
    }, {
        key: "_reformDate",
        value: function _reformDate(dateStr) {
            var dateObj = (0, _edtf.edtfParse)(dateStr);
            if (dateObj.type === 'Interval') {
                return {
                    'date-parts': [this._edtfToCSL(dateObj.values[0].values.slice(0, 3)), this._edtfToCSL(dateObj.values[1].values.slice(0, 3))]
                };
            } else {
                return {
                    'date-parts': [this._edtfToCSL(dateObj.values.slice(0, 3))]
                };
            }
        }
    }, {
        key: "_edtfToCSL",
        value: function _edtfToCSL(dateArray) {
            // Add 1 to month (0-11 in edtf.js === 1-12 in CSL json)
            if (dateArray.length > 1) {
                dateArray[1] = dateArray[1] + 1;
            }
            return dateArray;
        }
    }, {
        key: "_reformName",
        value: function _reformName(theNames) {
            var reformedNames = [],
                that = this;
            theNames.forEach(function (name) {
                var reformedName = {};
                if (name.literal) {
                    reformedName['literal'] = that._reformText(name.literal);
                } else {
                    reformedName['given'] = that._reformText(name.given);
                    reformedName['family'] = that._reformText(name.family);
                    if (name.suffix) {
                        reformedName['suffix'] = that._reformText(name.suffix);
                    }
                    if (name.prefix) {
                        if (name.useprefix === true) {
                            reformedName['non-dropping-particle'] = that._reformText(name.prefix);
                        } else {
                            reformedName['dropping-particle'] = that._reformText(name.prefix);
                        }
                    }
                    reformedName['family'] = that._reformText(name['family']);
                }
                reformedNames.push(reformedName);
            });
            return reformedNames;
        }
    }, {
        key: "output",
        get: function get() {
            for (var bibId in this.bibDB) {
                if (this.pks.indexOf(bibId) !== -1) {
                    this.cslDB[bibId] = this.getCSLEntry(bibId);
                    this.cslDB[bibId].id = bibId;
                }
            }
            return this.cslDB;
        }
    }]);
    return CSLExporter;
}();