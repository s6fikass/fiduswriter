"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BibLatexExporter = undefined;

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _const = require("./const");

var _const2 = require("../const");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Export a list of bibliography items to bibLateX and serve the file to the user as a ZIP-file.
 * @class BibLatexExporter
 * @param pks A list of pks of the bibliography items that are to be exported.
 */

var TAGS = {
    'strong': { open: '\\mkbibbold{', close: '}' },
    'em': { open: '\\mkbibitalic{', close: '}' },
    'smallcaps': { open: '\\textsc{', close: '}' },
    'enquote': { open: '\\enquote{', close: '}' },
    'nocase': { open: '{{', close: '}}' },
    'sub': { open: '_{', close: '}' },
    'sup': { open: '^{', close: '}' },
    'math': { open: '$', close: '$' },
    'url': { open: "\\url{", close: '}', verbatim: true }
};

var BibLatexExporter = exports.BibLatexExporter = function () {
    function BibLatexExporter(bibDB) {
        var pks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        (0, _classCallCheck3.default)(this, BibLatexExporter);

        this.bibDB = bibDB; // The bibliography database to export from.
        if (pks) {
            this.pks = pks; // A list of pk values of the bibliography items to be exported.
        } else {
            this.pks = (0, _keys2.default)(bibDB); // If none are selected, all keys are exporter
        }
        this.config = config;
        this.warnings = [];
    }

    (0, _createClass3.default)(BibLatexExporter, [{
        key: "_reformKey",
        value: function _reformKey(theValue, fKey) {
            if (typeof theValue === 'string') {
                var fieldType = _const2.BibFieldTypes[fKey];
                if (Array.isArray(fieldType['options'])) {
                    return this._escapeTeX(theValue);
                } else {
                    return this._escapeTeX(fieldType['options'][theValue]['biblatex']);
                }
            } else {
                return this._reformText(theValue);
            }
        }
    }, {
        key: "_reformRange",
        value: function _reformRange(theValue) {
            var _this = this;

            var that = this;
            return theValue.map(function (range) {
                return range.map(function (text) {
                    return _this._reformText(text);
                }).join('--');
            }).join(',');
        }
    }, {
        key: "_reformName",
        value: function _reformName(theValue) {
            var names = [],
                that = this;
            theValue.forEach(function (name) {
                if (name.literal) {
                    var literal = that._reformText(name.literal);
                    names.push("{" + literal + "}");
                } else {
                    var family = name.family ? that._reformText(name.family) : '';
                    var given = name.given ? that._reformText(name.given) : '';
                    var suffix = name.suffix ? that._reformText(name.suffix) : false;
                    var prefix = name.prefix ? that._reformText(name.prefix) : false;
                    var useprefix = name.useprefix ? name.useprefix : false;
                    if (that.config.traditionalNames) {
                        if (suffix && prefix) {
                            names.push("{" + prefix + " " + family + "}, {" + suffix + "}, {" + given + "}");
                        } else if (suffix) {
                            names.push("{" + family + "}, {" + suffix + "}, {" + given + "}");
                        } else if (prefix) {
                            names.push("{" + prefix + " " + family + "}, {" + given + "}");
                        } else {
                            names.push("{" + family + "}, {" + given + "}");
                        }
                    } else {
                        var nameParts = [];
                        if (given.length) {
                            nameParts.push(that._protectNamePart("given={" + given + "}"));
                        }
                        if (family.length) {
                            nameParts.push(that._protectNamePart("family={" + family + "}"));
                        }
                        if (suffix) {
                            nameParts.push(that._protectNamePart("suffix={" + suffix + "}"));
                        }
                        if (prefix) {
                            nameParts.push(that._protectNamePart("prefix={" + prefix + "}"));
                            nameParts.push("useprefix=" + name.useprefix);
                        }
                        names.push("{" + nameParts.join(', ') + "}");
                    }
                }
            });
            return names.join(' and ');
        }
    }, {
        key: "_protectNamePart",
        value: function _protectNamePart(namePart) {
            if (namePart.includes(',')) {
                return "\"" + namePart + "\"";
            } else {
                return namePart;
            }
        }
    }, {
        key: "_escapeTeX",
        value: function _escapeTeX(theValue) {
            if ('string' != typeof theValue) {
                return false;
            }
            var len = _const.TexSpecialChars.length;
            for (var i = 0; i < len; i++) {
                theValue = theValue.replace(_const.TexSpecialChars[i][0], _const.TexSpecialChars[i][1]);
            }
            return theValue;
        }
    }, {
        key: "_reformText",
        value: function _reformText(theValue) {
            var _this2 = this;

            var that = this,
                latex = '',
                lastMarks = [];
            theValue.forEach(function (node) {
                if (node.type === 'variable') {
                    // This is an undefined variable
                    // This should usually not happen, as CSL doesn't know what to
                    // do with these. We'll put them into an unsupported tag.
                    latex += "} # " + node.attrs.variable + " # {";
                    _this2.warnings.push({
                        type: 'undefined_variable',
                        variable: node.attrs.variable
                    });
                    return;
                }
                var newMarks = [];
                if (node.marks) {
                    (function () {
                        var mathMode = false;
                        node.marks.forEach(function (mark) {
                            // We need to activate mathmode for the lowest level sub/sup node.
                            if ((mark.type === 'sup' || mark.type === 'sub') && !mathMode) {
                                newMarks.push('math');
                                newMarks.push(mark.type);
                                mathMode = true;
                            } else if (mark.type === 'nocase') {
                                // No case has to be applied at the top level to be effective.
                                newMarks.unshift(mark.type);
                            } else {
                                newMarks.push(mark.type);
                            }
                        });
                    })();
                }
                // close all tags that are not present in current text node.
                // Go through last marksd in revrse order to close innermost tags first.
                var closing = false;
                lastMarks.slice().reverse().forEach(function (mark, rIndex) {
                    var index = lastMarks.length - rIndex;
                    if (mark != newMarks[index]) {
                        closing = true;
                    }
                    if (closing) {
                        latex += TAGS[mark].close;
                        // If not inside of a nocase, add a protective brace around tag.
                        if (lastMarks[0] !== 'nocase' && TAGS[mark].open[0] === '\\') {
                            latex += '}';
                        }
                    }
                });
                // open all new tags that were not present in the last text node.
                var opening = false,
                    verbatim = false;
                newMarks.forEach(function (mark, index) {
                    if (mark != lastMarks[index]) {
                        opening = true;
                    }
                    if (opening) {
                        // If not inside of a nocase, add a protective brace around tag.
                        if (newMarks[0] !== 'nocase' && TAGS[mark].open[0] === '\\') {
                            latex += '{';
                        }
                        latex += TAGS[mark].open;
                        if (TAGS[mark].verbatim) {
                            verbatim = true;
                        }
                    }
                });
                if (verbatim) {
                    latex += node.text;
                } else {
                    latex += that._escapeTeX(node.text);
                }
                lastMarks = newMarks;
            });
            // Close all still open tags
            lastMarks.slice().reverse().forEach(function (mark) {
                latex += TAGS[mark].close;
            });
            return latex;
        }
    }, {
        key: "_getBibtexString",
        value: function _getBibtexString(biblist) {
            var len = biblist.length,
                str = '';
            for (var i = 0; i < len; i++) {
                if (0 < i) {
                    str += '\n\n';
                }
                var data = biblist[i];
                str += "@" + data.type + "{" + data.key;
                for (var vKey in data.values) {
                    var value = ("{" + data.values[vKey] + "}").replace(/\{\} \# /g, '').replace(/\# \{\}/g, '');
                    str += ",\n" + vKey + " = " + value;
                }
                str += "\n}";
            }
            return str;
        }
    }, {
        key: "output",
        get: function get() {
            var _this3 = this;

            var that = this;
            this.bibtexArray = [];
            this.bibtexStr = '';

            var len = this.pks.length;

            for (var i = 0; i < len; i++) {
                var pk = this.pks[i];
                var bib = this.bibDB[pk];
                var bibEntry = {
                    'type': _const2.BibTypes[bib['bib_type']]['biblatex'],
                    'key': bib['entry_key'].length ? bib['entry_key'] : 'Undefined'
                };
                var fValues = {};

                var _loop = function _loop(fKey) {
                    if (!_const2.BibFieldTypes[fKey]) {
                        return "continue";
                    }
                    var fValue = bib.fields[fKey];
                    var fType = _const2.BibFieldTypes[fKey]['type'];
                    var key = _const2.BibFieldTypes[fKey]['biblatex'];
                    switch (fType) {
                        case 'f_date':
                            fValues[key] = fValue; // EDTF 1.0 level 0/1 compliant string.
                            break;
                        case 'f_integer':
                            fValues[key] = _this3._reformText(fValue);
                            break;
                        case 'f_key':
                            fValues[key] = _this3._reformKey(fValue, fKey);
                            break;
                        case 'f_literal':
                        case 'f_long_literal':
                            fValues[key] = _this3._reformText(fValue);
                            break;
                        case 'l_range':
                            fValues[key] = _this3._reformRange(fValue);
                            break;
                        case 'f_title':
                            fValues[key] = _this3._reformText(fValue);
                            break;
                        case 'f_uri':
                        case 'f_verbatim':
                            fValues[key] = fValue.replace(/{|}/g, ''); // TODO: balanced braces should probably be ok here.
                            break;
                        case 'l_key':
                            fValues[key] = _this3._escapeTeX(fValue.map(function (key) {
                                return that._reformKey(key, fKey);
                            }).join(' and '));
                            break;
                        case 'l_literal':
                            fValues[key] = fValue.map(function (text) {
                                return that._reformText(text);
                            }).join(' and ');
                            break;
                        case 'l_name':
                            fValues[key] = _this3._reformName(fValue);
                            break;
                        case 'l_tag':
                            fValues[key] = _this3._escapeTeX(fValue.join(', '));
                            break;
                        default:
                            console.warn("Unrecognized type: " + fType + "!");
                    }
                };

                for (var fKey in bib.fields) {
                    var _ret2 = _loop(fKey);

                    if (_ret2 === "continue") continue;
                }
                bibEntry.values = fValues;
                this.bibtexArray[this.bibtexArray.length] = bibEntry;
            }
            this.bibtexStr = this._getBibtexString(this.bibtexArray);
            return this.bibtexStr;
        }
    }]);
    return BibLatexExporter;
}();