'use strict';

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DAY = /^days?$/i;
var MONTH = /^months?$/i;
var YEAR = /^years?$/i;
var SYMBOL = /^[xX]$/;
var SYMBOLS = /[xX]/g;
var PATTERN = /^[0-9xXdDmMyY]{8}$/;
var YYYYMMDD = 'YYYYMMDD'.split('');
var MAXDAYS = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

var pow = Math.pow,
    max = Math.max,
    min = Math.min;

/**
 * Bitmasks are used to set Unspecified, Uncertain and
 * Approximate flags for a Date. The bitmask for one
 * feature corresponds to a numeric value based on the
 * following pattern:
 *
 *           YYYYMMDD
 *           --------
 *   Day     00000011
 *   Month   00001100
 *   Year    11110000
 *
 */

var Bitmask = function () {
  (0, _createClass3.default)(Bitmask, null, [{
    key: 'test',
    value: function test(a, b) {
      return this.convert(a) & this.convert(b);
    }
  }, {
    key: 'convert',
    value: function convert() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // eslint-disable-line complexity
      value = value || 0;

      if (value instanceof Bitmask) return value.value;

      switch (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) {
        case 'number':
          return value;

        case 'boolean':
          return value ? Bitmask.YMD : 0;

        case 'string':
          if (DAY.test(value)) return Bitmask.DAY;
          if (MONTH.test(value)) return Bitmask.MONTH;
          if (YEAR.test(value)) return Bitmask.YEAR;
          if (PATTERN.test(value)) return Bitmask.compute(value);
        // fall through!

        default:
          throw new Error('invalid value: ' + value);
      }
    }
  }, {
    key: 'compute',
    value: function compute(value) {
      return value.split('').reduce(function (memo, c, idx) {
        return memo | (SYMBOL.test(c) ? pow(2, idx) : 0);
      }, 0);
    }
  }, {
    key: 'values',
    value: function values(mask) {
      var digit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var num = Bitmask.numbers(mask, digit).split('');
      var values = [Number(num.slice(0, 4).join(''))];

      if (num.length > 4) values.push(Number(num.slice(4, 6).join('')));
      if (num.length > 6) values.push(Number(num.slice(6, 8).join('')));

      return Bitmask.normalize(values);
    }
  }, {
    key: 'numbers',
    value: function numbers(mask) {
      var digit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      return mask.replace(SYMBOLS, digit);
    }
  }, {
    key: 'normalize',
    value: function normalize(values) {
      if (values.length > 1) values[1] = min(11, max(0, values[1] - 1));

      if (values.length > 2) values[2] = min(MAXDAYS[values[1]] || NaN, max(1, values[2]));

      return values;
    }
  }]);

  function Bitmask() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    (0, _classCallCheck3.default)(this, Bitmask);

    this.value = Bitmask.convert(value);
  }

  (0, _createClass3.default)(Bitmask, [{
    key: 'test',
    value: function test() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this.value & Bitmask.convert(value);
    }
  }, {
    key: 'bit',
    value: function bit(k) {
      return this.value & pow(2, k);
    }
  }, {
    key: 'add',
    value: function add(value) {
      return this.value = this.value | Bitmask.convert(value), this;
    }
  }, {
    key: 'set',
    value: function set() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return this.value = Bitmask.convert(value), this;
    }
  }, {
    key: 'mask',
    value: function mask() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : YYYYMMDD;

      var _this = this;

      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var symbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'X';

      return input.map(function (c, idx) {
        return _this.bit(offset + idx) ? symbol : c;
      });
    }
  }, {
    key: 'masks',
    value: function masks(values) {
      var _this2 = this;

      var symbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'X';

      var offset = 0;

      return values.map(function (value) {
        var mask = _this2.mask(value.split(''), offset, symbol);
        offset = offset + mask.length;

        return mask.join('');
      });
    }
  }, {
    key: 'max',
    value: function max(_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 3),
          year = _ref2[0],
          month = _ref2[1],
          day = _ref2[2];

      // eslint-disable-line complexity
      if (!year) return [];

      year = Number(this.test(Bitmask.YEAR) ? this.masks([year], '9')[0] : year);

      if (!month) return [year];

      month = Number(month) - 1;

      switch (this.test(Bitmask.MONTH)) {
        case Bitmask.MONTH:
          month = 11;
          break;
        case Bitmask.MX:
          month = month < 9 ? 8 : 11;
          break;
        case Bitmask.XM:
          month = (month + 1) % 10;
          month = month < 3 ? month + 9 : month - 1;
          break;
      }

      if (!day) return [year, month];

      day = Number(day);

      switch (this.test(Bitmask.DAY)) {
        case Bitmask.DAY:
          day = MAXDAYS[month];
          break;
        case Bitmask.DX:
          day = min(MAXDAYS[month], day + (9 - day % 10));
          break;
        case Bitmask.XD:
          day = day % 10;

          if (month === 1) {
            day = day === 9 && !leap(year) ? day + 10 : day + 20;
          } else {
            day = day < 2 ? day + 30 : day + 20;
            if (day > MAXDAYS[month]) day = day - 10;
          }

          break;
      }

      if (month === 1 && day > 28 && !leap(year)) {
        day = 28;
      }

      return [year, month, day];
    }
  }, {
    key: 'marks',
    value: function marks(values) {
      var _this3 = this;

      var symbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';

      return values.map(function (value, idx) {
        return [_this3.qualified(idx * 2) ? symbol : '', value, _this3.qualified(idx * 2 + 1) ? symbol : ''].join('');
      });
    }
  }, {
    key: 'qualified',
    value: function qualified(idx) {
      // eslint-disable-line complexity
      switch (idx) {
        case 1:
          return this.value === Bitmask.YEAR || this.value & Bitmask.YEAR && !(this.value & Bitmask.MONTH);
        case 2:
          return this.value === Bitmask.MONTH || this.value & Bitmask.MONTH && !(this.value & Bitmask.YEAR);
        case 3:
          return this.value === Bitmask.YM;
        case 4:
          return this.value === Bitmask.DAY || this.value & Bitmask.DAY && this.value !== Bitmask.YMD;
        case 5:
          return this.value === Bitmask.YMD;
        default:
          return false;
      }
    }
  }, {
    key: 'qualify',
    value: function qualify(idx) {
      return this.value = this.value | Bitmask.UA[idx], this;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.value;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var symbol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'X';

      return this.masks(['YYYY', 'MM', 'DD'], symbol).join('-');
    }
  }, {
    key: 'day',
    get: function get() {
      return this.test(Bitmask.DAY);
    }
  }, {
    key: 'month',
    get: function get() {
      return this.test(Bitmask.MONTH);
    }
  }, {
    key: 'year',
    get: function get() {
      return this.test(Bitmask.YEAR);
    }
  }]);
  return Bitmask;
}();

Bitmask.prototype.is = Bitmask.prototype.test;

function leap(year) {
  if (year % 4 > 0) return false;
  if (year % 100 > 0) return true;
  if (year % 400 > 0) return false;
  return true;
}

Bitmask.DAY = Bitmask.D = Bitmask.compute('yyyymmxx');
Bitmask.MONTH = Bitmask.M = Bitmask.compute('yyyyxxdd');
Bitmask.YEAR = Bitmask.Y = Bitmask.compute('xxxxmmdd');

Bitmask.MD = Bitmask.M | Bitmask.D;
Bitmask.YMD = Bitmask.Y | Bitmask.MD;
Bitmask.YM = Bitmask.Y | Bitmask.M;

Bitmask.YYXX = Bitmask.compute('yyxxmmdd');
Bitmask.YYYX = Bitmask.compute('yyyxmmdd');
Bitmask.XXXX = Bitmask.compute('xxxxmmdd');

Bitmask.DX = Bitmask.compute('yyyymmdx');
Bitmask.XD = Bitmask.compute('yyyymmxd');
Bitmask.MX = Bitmask.compute('yyyymxdd');
Bitmask.XM = Bitmask.compute('yyyyxmdd');

/*
 * Map each UA symbol position to a mask.
 *
 *   ~YYYY~-~MM~-~DD~
 *   0    1 2  3 4  5
 */
Bitmask.UA = [Bitmask.YEAR, Bitmask.YEAR, // YEAR !DAY
Bitmask.MONTH, Bitmask.YM, Bitmask.DAY, // YEARDAY
Bitmask.YMD];

module.exports = Bitmask;