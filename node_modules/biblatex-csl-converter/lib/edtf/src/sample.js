/*
 * Based on `nearley-unparse`
 * https://github.com/Hardmath123/nearley/blob/master/bin/nearley-unparse.js
 *
 * Copyright (c) 2014 Hardmath123
 */
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assert = require('assert');
var randexp = require('randexp');

var types = (0, _keys2.default)(require('./types'));

var _require = require('./grammar'),
    Rules = _require.ParserRules;

var floor = Math.floor,
    random = Math.random;


var NAMES = [{
  any: 'L0', Date: 'date_time', Century: 'century', Interval: 'L0i'
}, {
  any: 'L1', Date: 'L1d', Year: 'L1Y', Season: 'L1S', Interval: 'L1i'
}, {
  any: 'L2', Date: 'L2s', Year: 'L2Y', Season: 'L2S', Interval: 'L2i',
  Decade: 'L2D', Set: 'set', List: 'list'
}];

module.exports = {
  sample: _regenerator2.default.mark(function sample() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        count = _ref.count,
        level = _ref.level,
        type = _ref.type;

    var name, i;
    return _regenerator2.default.wrap(function sample$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            name = 'edtf';


            if (typeof count !== 'number') count = Infinity;

            assert(count > 0, 'invalid count ' + count);

            if (!(typeof level !== 'undefined')) {
              _context.next = 9;
              break;
            }

            assert([0, 1, 2].includes(level), 'invalid level ' + level);

            if (typeof type !== 'undefined') assert(types.includes(type), 'invalid type ' + type);

            name = NAMES[level][type || 'any'];

            if (name) {
              _context.next = 9;
              break;
            }

            throw new Error('impossible to generate ' + type + ' at level ' + level);

          case 9:
            i = 0;

          case 10:
            if (!(i < count)) {
              _context.next = 16;
              break;
            }

            _context.next = 13;
            return module.exports.gen(name);

          case 13:
            ++i;
            _context.next = 10;
            break;

          case 16:
          case 'end':
            return _context.stop();
        }
      }
    }, sample, this);
  }),
  gen: function gen() {
    var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'edtf';

    var output = [];
    var stack = [root];

    var _loop = function _loop() {
      var name = stack.pop();

      if (typeof name === 'string') {
        var rules = Rules.filter(function (r) {
          return r.name === name;
        });

        if (rules.length > 0) {
          var _sample = rules[floor(random() * rules.length)];

          for (var j = _sample.symbols.length - 1; j >= 0; --j) {
            stack.push(_sample.symbols[j]);
          }
        } else throw new Error('No match for rule "' + name + '"!');

        return 'continue';
      }

      if (name.test) {
        output.push(new randexp(name).gen());
        return 'continue';
      }

      if (name.literal) {
        output.push(name.literal);
        return 'continue';
      }
    };

    while (stack.length > 0) {
      var _ret = _loop();

      if (_ret === 'continue') continue;
    }

    return output.join('').replace(/ +/g, ''); // filter excessive whitespace
  }
};