'use strict';

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Bitmask = require('./bitmask');
var assign = _assign2.default;


var util = {
  num: function num(data) {
    return Number(Array.isArray(data) ? data.join('') : data);
  },
  join: function join(data) {
    return data.join('');
  },
  zero: function zero() {
    return 0;
  },
  nothing: function nothing() {
    return null;
  },
  pick: function pick() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args.length === 1 ? function (data) {
      return data[args[0]];
    } : function (data) {
      return util.concat(data, args);
    };
  },
  pluck: function pluck() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return function (data) {
      return args.map(function (i) {
        return data[i];
      });
    };
  },
  concat: function concat(data) {
    var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : data.keys();

    return (0, _from2.default)(idx).reduce(function (memo, i) {
      return data[i] !== null ? memo.concat(data[i]) : memo;
    }, []);
  },
  merge: function merge() {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    if ((0, _typeof3.default)(args[args.length - 1]) === 'object') var extra = args.pop();

    return function (data) {
      return assign(args.reduce(function (a, i) {
        return assign(a, data[i]);
      }, {}), extra);
    };
  },
  interval: function interval(level) {
    return function (data) {
      return {
        values: [data[0], data[2]],
        type: 'Interval',
        level: level
      };
    };
  },
  masked: function masked() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unspecified';
    var symbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'X';

    return function (data, _, reject) {
      var mask = data.join('').replace(/-/g, '');

      return mask.indexOf(symbol) === -1 ? reject : (0, _defineProperty3.default)({
        values: Bitmask.values(mask)
      }, type, Bitmask.compute(mask));
    };
  },
  date: function date(values) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    return assign({
      type: 'Date',
      level: level,
      values: Bitmask.normalize(values.map(Number))
    }, extra);
  },
  year: function year(values) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    return assign({
      type: 'Year',
      level: level,
      values: values.map(Number)
    }, extra);
  },
  century: function century(_century) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    return {
      type: 'Century',
      level: level,
      values: [_century]
    };
  },
  decade: function decade(_decade) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

    return {
      type: 'Decade',
      level: level,
      values: [_decade]
    };
  },
  datetime: function datetime(data) {
    return {
      values: Bitmask.normalize(data[0].map(Number)).concat(data[2]),
      offset: data[3],
      type: 'Date',
      level: 0
    };
  },
  season: function season(data) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    return {
      type: 'Season',
      level: level,
      values: [Number(data[0]), Number(data[2])]
    };
  },
  list: function list(data) {
    return assign({ values: data[1], level: 2 }, data[0], data[2]);
  },
  qualify: function qualify(_ref2, _, reject) {
    var _ref3 = (0, _slicedToArray3.default)(_ref2, 1),
        parts = _ref3[0];

    var q = {
      uncertain: new Bitmask(), approximate: new Bitmask()
    };

    var values = parts.map(function (_ref4, idx) {
      var _ref5 = (0, _slicedToArray3.default)(_ref4, 3),
          lhs = _ref5[0],
          part = _ref5[1],
          rhs = _ref5[2];

      for (var ua in lhs) {
        q[ua].qualify(idx * 2);
      }for (var _ua in rhs) {
        q[_ua].qualify(1 + idx * 2);
      }return part;
    });

    return !q.uncertain.value && !q.approximate.value ? reject : assign(util.date(values, 2), {
      uncertain: q.uncertain.value,
      approximate: q.approximate.value
    });
  }
};

module.exports = util;