'use strict';

var _iterator = require('babel-runtime/core-js/symbol/iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _defineProperty = require('babel-runtime/core-js/object/define-property');

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assert = require('assert');

var Bitmask = require('./bitmask');
var ExtDateTime = require('./interface');
var mixin = require('./mixin');

var _require = require('./format'),
    format = _require.format;

var abs = Math.abs;
var isArray = Array.isArray;
var prop = _defineProperty2.default;


var P = new _weakMap2.default();
var U = new _weakMap2.default();
var A = new _weakMap2.default();
var X = new _weakMap2.default();

var PM = [Bitmask.YMD, Bitmask.Y, Bitmask.YM, Bitmask.YMD];

var Date = function (_global$Date) {
  (0, _inherits3.default)(Date, _global$Date);

  function Date() {
    var _ref;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _classCallCheck3.default)(this, Date);
    // eslint-disable-line complexity
    var precision = 0;
    var uncertain = void 0,
        approximate = void 0,
        unspecified = void 0;

    switch (args.length) {
      case 0:
        break;

      case 1:
        switch ((0, _typeof3.default)(args[0])) {
          case 'number':
            break;

          case 'string':
            args = [Date.parse(args[0])];
          // eslint-disable-line no-fallthrough

          case 'object':
            if (isArray(args[0])) args[0] = { values: args[0] };

            {
              var obj = args[0];

              assert(obj != null);
              if (obj.type) assert.equal('Date', obj.type);

              if (obj.values && obj.values.length) {
                precision = obj.values.length;
                args = obj.values.slice();

                // ECMA Date constructor needs at least two date parts!
                if (args.length < 2) args.push(0);

                if (obj.offset) {
                  if (args.length < 3) args.push(1);
                  while (args.length < 5) {
                    args.push(0);
                  } // ECMA Date constructor handles overflows so we
                  // simply add the offset!
                  args[4] = args[4] + obj.offset;
                }

                args = [ExtDateTime.UTC.apply(ExtDateTime, (0, _toConsumableArray3.default)(args))];
              }

              uncertain = obj.uncertain;
              approximate = obj.approximate;
              unspecified = obj.unspecified;
            }
            break;

          default:
            throw new RangeError('Invalid time value');
        }

        break;

      default:
        precision = args.length;
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Date.__proto__ || (0, _getPrototypeOf2.default)(Date)).call.apply(_ref, [this].concat((0, _toConsumableArray3.default)(args))));

    _this.precision = precision;

    _this.uncertain = uncertain;
    _this.approximate = approximate;
    _this.unspecified = unspecified;

    prop(_this, 'format', {
      value: format.bind(null, _this)
    });
    return _this;
  }

  (0, _createClass3.default)(Date, [{
    key: 'next',


    /**
     * Returns the next second, day, month, or year, depending on
     * the current date's precision. Uncertain, approximate and
     * unspecified masks are copied.
     */
    value: function next() {
      var k = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var values = this.values,
          unspecified = this.unspecified,
          uncertain = this.uncertain,
          approximate = this.approximate;


      if (unspecified.value) {
        values = unspecified.max(values.map(Date.pad));
      }

      values.push(values.pop() + k);

      return new Date({ values: values, unspecified: unspecified, uncertain: uncertain, approximate: approximate });
    }
  }, {
    key: 'prev',
    value: function prev() {
      var k = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this.next(-k);
    }
  }, {
    key: 'until',
    value: _regenerator2.default.mark(function until(then) {
      return _regenerator2.default.wrap(function until$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this;

            case 2:
              if (!this.compare(then)) {
                _context.next = 4;
                break;
              }

              return _context.delegateYield(this.between(then), 't0', 4);

            case 4:
            case 'end':
              return _context.stop();
          }
        }
      }, until, this);
    })
  }, {
    key: 'through',
    value: _regenerator2.default.mark(function through(then) {
      return _regenerator2.default.wrap(function through$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(this.until(then), 't0', 1);

            case 1:
              if (!this.compare(then)) {
                _context2.next = 4;
                break;
              }

              _context2.next = 4;
              return then;

            case 4:
            case 'end':
              return _context2.stop();
          }
        }
      }, through, this);
    })
  }, {
    key: 'between',
    value: _regenerator2.default.mark(function between(then) {
      var cur, dir;
      return _regenerator2.default.wrap(function between$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              then = Date.from(then);

              cur = this;
              dir = this.compare(then);

              if (dir) {
                _context3.next = 5;
                break;
              }

              return _context3.abrupt('return');

            case 5:
              cur = cur.next(-dir);

              if (!(cur.compare(then) !== dir)) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt('break', 12);

            case 8:
              _context3.next = 10;
              return cur;

            case 10:
              _context3.next = 5;
              break;

            case 12:
            case 'end':
              return _context3.stop();
          }
        }
      }, between, this);
    })
  }, {
    key: _iterator2.default,
    value: _regenerator2.default.mark(function value() {
      var cur;
      return _regenerator2.default.wrap(function value$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              cur = this;

            case 1:
              if (!(cur <= this.max)) {
                _context4.next = 7;
                break;
              }

              _context4.next = 4;
              return cur;

            case 4:
              cur = cur.next();
              _context4.next = 1;
              break;

            case 7:
            case 'end':
              return _context4.stop();
          }
        }
      }, value, this);
    })
  }, {
    key: 'toEDTF',
    value: function toEDTF() {
      if (!this.precision) return this.toISOString();

      var values = this.values.map(Date.pad);

      if (this.unspecified.value) return this.unspecified.masks(values).join('-');

      if (this.uncertain.value) values = this.uncertain.marks(values, '?');

      if (this.approximate.value) {
        values = this.approximate.marks(values, '~').map(function (value) {
          return value.replace(/(~\?)|(\?~)/, '%');
        });
      }

      return values.join('-');
    }
  }, {
    key: 'localize',
    value: function localize() {
      return this.format.apply(this, arguments).format(this);
    }
  }, {
    key: 'bits',
    value: function bits(value) {
      if (value === true) value = PM[this.precision];

      return new Bitmask(value);
    }
  }, {
    key: 'precision',
    set: function set(value) {
      P.set(this, value > 3 ? 0 : Number(value));
    },
    get: function get() {
      return P.get(this);
    }
  }, {
    key: 'uncertain',
    set: function set(value) {
      U.set(this, this.bits(value));
    },
    get: function get() {
      return U.get(this);
    }
  }, {
    key: 'approximate',
    set: function set(value) {
      A.set(this, this.bits(value));
    },
    get: function get() {
      return A.get(this);
    }
  }, {
    key: 'unspecified',
    set: function set(value) {
      X.set(this, new Bitmask(value));
    },
    get: function get() {
      return X.get(this);
    }
  }, {
    key: 'atomic',
    get: function get() {
      return !(this.precision || this.unspecified.value);
    }
  }, {
    key: 'min',
    get: function get() {
      // TODO uncertain and approximate
      return this.getTime();
    }
  }, {
    key: 'max',
    get: function get() {
      // TODO uncertain and approximate
      return this.atomic ? this.getTime() : this.next() - 1;
    }
  }, {
    key: 'year',
    get: function get() {
      return this.getUTCFullYear();
    }
  }, {
    key: 'month',
    get: function get() {
      return this.getUTCMonth();
    }
  }, {
    key: 'date',
    get: function get() {
      return this.getUTCDate();
    }
  }, {
    key: 'hours',
    get: function get() {
      return this.getUTCHours();
    }
  }, {
    key: 'minutes',
    get: function get() {
      return this.getUTCMinutes();
    }
  }, {
    key: 'seconds',
    get: function get() {
      return this.getUTCSeconds();
    }
  }, {
    key: 'values',
    get: function get() {
      switch (this.precision) {
        case 1:
          return [this.year];
        case 2:
          return [this.year, this.month];
        case 3:
          return [this.year, this.month, this.date];
        default:
          return [this.year, this.month, this.date, this.hours, this.minutes, this.seconds];
      }
    }
  }], [{
    key: 'pad',
    value: function pad(number) {
      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // idx 0 = year, 1 = month, ...
      if (!idx) {
        var k = abs(number);
        var sign = k === number ? '' : '-';

        if (k < 10) return sign + '000' + k;
        if (k < 100) return sign + '00' + k;
        if (k < 1000) return sign + '0' + k;

        return '' + number;
      }

      if (idx === 1) number = number + 1;

      return number < 10 ? '0' + number : '' + number;
    }
  }]);
  return Date;
}(global.Date);

mixin(Date, ExtDateTime);

module.exports = Date;